{"version":3,"file":"sorted-set-c0d1c483.js","sources":["../../node_modules/js-sorted-set/sorted-set.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = global || self, global['sorted-set'] = factory());\n}(this, (function () { 'use strict';\n\n  class AbstractSortedSet {\n    constructor(options) {\n      if ((options != null ? options.strategy : void 0) == null) {\n        throw 'Must pass options.strategy, a strategy';\n      }\n\n      if ((options != null ? options.comparator : void 0) == null) {\n        throw 'Must pass options.comparator, a comparator';\n      }\n\n      if ((options != null ? options.onInsertConflict : void 0) == null) {\n        throw 'Must pass options.onInsertConflict, a function';\n      }\n\n      this.priv = new options.strategy(options);\n      this.length = 0;\n    }\n\n    insert(value) {\n      this.priv.insert(value);\n      this.length += 1;\n      return this;\n    }\n\n    remove(value) {\n      this.priv.remove(value);\n      this.length -= 1;\n      return this;\n    }\n\n    clear() {\n      this.priv.clear();\n      this.length = 0;\n      return this;\n    }\n\n    contains(value) {\n      return this.priv.contains(value);\n    } // Returns this set as an Array\n\n\n    toArray() {\n      return this.priv.toArray();\n    }\n\n    forEach(callback, thisArg) {\n      this.priv.forEachImpl(callback, this, thisArg);\n      return this;\n    }\n\n    map(callback, thisArg) {\n      const ret = [];\n      this.forEach(function (value, index, self) {\n        return ret.push(callback.call(thisArg, value, index, self));\n      });\n      return ret;\n    }\n\n    filter(callback, thisArg) {\n      const ret = [];\n      this.forEach(function (value, index, self) {\n        if (callback.call(thisArg, value, index, self)) {\n          return ret.push(value);\n        }\n      });\n      return ret;\n    }\n\n    every(callback, thisArg) {\n      let ret = true;\n      this.forEach(function (value, index, self) {\n        if (ret && !callback.call(thisArg, value, index, self)) {\n          ret = false;\n        }\n      });\n      return ret;\n    }\n\n    some(callback, thisArg) {\n      let ret = false;\n      this.forEach(function (value, index, self) {\n        if (!ret && callback.call(thisArg, value, index, self)) {\n          ret = true;\n        }\n      });\n      return ret;\n    } // An iterator is similar to a C++ iterator: it points _before_ a value.\n    // So in this sorted set:\n    //   | 1 | 2 | 3 | 4 | 5 |\n    //   ^a      ^b          ^c\n    // `a` is a pointer to the beginning of the iterator. `a.value()` returns\n    // `3`. `a.previous()` returns `null`. `a.setValue()` works, if\n    // `options.allowSetValue` is true.\n    // `b` is a pointer to the value `3`. `a.previous()` and `a.next()` both do\n    // the obvious.\n    // `c` is a pointer to the `null` value. `c.previous()` works; `c.next()`\n    // returns null. `c.setValue()` throws an exception, even if\n    // `options.allowSetValue` is true.\n    // Iterators have `hasNext()` and `hasPrevious()` methods, too.\n    // Iterators are immutible. `iterator.next()` returns a new iterator.\n    // Iterators become invalid as soon as `insert()` or `remove()` is called.\n\n\n    findIterator(value) {\n      return this.priv.findIterator(value);\n    } // Finds an iterator pointing to the lowest possible value.\n\n\n    beginIterator() {\n      return this.priv.beginIterator();\n    } // Finds an iterator pointing to the `null` value.\n\n\n    endIterator() {\n      return this.priv.endIterator();\n    }\n\n  }\n\n  class Iterator {\n    constructor(priv, index1) {\n      this.priv = priv;\n      this.index = index1;\n      this.data = this.priv.data;\n    }\n\n    hasNext() {\n      return this.index < this.data.length;\n    }\n\n    hasPrevious() {\n      return this.index > 0;\n    }\n\n    value() {\n      if (this.index < this.data.length) {\n        return this.data[this.index];\n      } else {\n        return null;\n      }\n    }\n\n    setValue(value) {\n      if (!this.priv.options.allowSetValue) {\n        throw 'Must set options.allowSetValue';\n      }\n\n      if (!this.hasNext()) {\n        throw 'Cannot set value at end of set';\n      }\n\n      return this.data[this.index] = value;\n    }\n\n    next() {\n      if (this.index >= this.data.length) {\n        return null;\n      } else {\n        return new Iterator(this.priv, this.index + 1);\n      }\n    }\n\n    previous() {\n      if (this.index <= 0) {\n        return null;\n      } else {\n        return new Iterator(this.priv, this.index - 1);\n      }\n    }\n\n  }\n\n  const binarySearchForIndex = (array, value, comparator) => {\n    let low = 0;\n    let high = array.length;\n\n    while (low < high) {\n      const mid = low + high >>> 1;\n\n      if (comparator(array[mid], value) < 0) {\n        low = mid + 1;\n      } else {\n        high = mid;\n      }\n    }\n\n    return low;\n  };\n\n  class ArrayStrategy {\n    constructor(options) {\n      this.options = options;\n      this.onInsertConflict = this.options.onInsertConflict;\n      this.comparator = this.options.comparator;\n      this.data = [];\n    }\n\n    toArray() {\n      return this.data;\n    }\n\n    insert(value) {\n      const index = binarySearchForIndex(this.data, value, this.comparator);\n\n      if (this.data[index] !== void 0 && this.comparator(this.data[index], value) === 0) {\n        return this.data.splice(index, 1, this.onInsertConflict(this.data[index], value));\n      } else {\n        return this.data.splice(index, 0, value);\n      }\n    }\n\n    remove(value) {\n      const index = binarySearchForIndex(this.data, value, this.comparator);\n\n      if (this.comparator(this.data[index], value) !== 0) {\n        throw 'Value not in set';\n      }\n\n      return this.data.splice(index, 1);\n    }\n\n    clear() {\n      return this.data.length = 0;\n    }\n\n    contains(value) {\n      const index = binarySearchForIndex(this.data, value, this.comparator);\n      return this.index !== this.data.length && this.comparator(this.data[index], value) === 0;\n    }\n\n    forEachImpl(callback, sortedSet, thisArg) {\n      const data = this.data;\n      const len = data.length;\n\n      for (let i = 0; i < len; i++) {\n        callback.call(thisArg, data[i], i, sortedSet);\n      }\n    }\n\n    findIterator(value) {\n      const index = binarySearchForIndex(this.data, value, this.comparator);\n      return new Iterator(this, index);\n    }\n\n    beginIterator() {\n      return new Iterator(this, 0);\n    }\n\n    endIterator() {\n      return new Iterator(this, this.data.length);\n    }\n\n  }\n\n  const descendAllTheWay = (leftOrRight, node) => {\n    // Assumes node._iteratorParentNode is set\n    while (node[leftOrRight] !== null) {\n      const parent = node;\n      node = node[leftOrRight];\n      node._iteratorParentNode = parent;\n    }\n\n    return node;\n  };\n\n  const moveCursor = (leftOrRight, node) => {\n    let parent, rightOrLeft;\n\n    if (node[leftOrRight] !== null) {\n      parent = node;\n      node = node[leftOrRight];\n      node._iteratorParentNode = parent;\n      rightOrLeft = leftOrRight === 'left' ? 'right' : 'left';\n      node = descendAllTheWay(rightOrLeft, node);\n    } else {\n      while ((parent = node._iteratorParentNode) !== null && parent[leftOrRight] === node) {\n        node = parent;\n      }\n\n      node = parent; // either null or the correct-direction parent\n    }\n\n    return node;\n  }; // The BinaryTreeIterator actually writes to the tree: it maintains a\n  // \"_iteratorParentNode\" variable on each node. Please ignore this.\n\n\n  class BinaryTreeIterator {\n    constructor(tree1, node1) {\n      this.tree = tree1;\n      this.node = node1;\n    }\n\n    next() {\n      if (this.node === null) {\n        return null;\n      } else {\n        const node = moveCursor('right', this.node);\n        return new BinaryTreeIterator(this.tree, node);\n      }\n    }\n\n    previous() {\n      if (this.node === null) {\n        if (this.tree.root === null) {\n          return null;\n        } else {\n          this.tree.root._iteratorParentNode = null;\n          const node = descendAllTheWay('right', this.tree.root);\n          return new BinaryTreeIterator(this.tree, node);\n        }\n      } else {\n        const node = moveCursor('left', this.node);\n\n        if (node === null) {\n          return null;\n        } else {\n          return new BinaryTreeIterator(this.tree, node);\n        }\n      }\n    }\n\n    hasNext() {\n      return this.node !== null;\n    }\n\n    hasPrevious() {\n      return this.previous() !== null;\n    }\n\n    value() {\n      if (this.node === null) {\n        return null;\n      } else {\n        return this.node.value;\n      }\n    }\n\n    setValue(value) {\n      if (!this.tree.options.allowSetValue) {\n        throw 'Must set options.allowSetValue';\n      }\n\n      if (!this.hasNext()) {\n        throw 'Cannot set value at end of set';\n      }\n\n      return this.node.value = value;\n    }\n\n  }\n\n  BinaryTreeIterator.find = function (tree, value, comparator) {\n    const root = tree.root;\n\n    if (root != null) {\n      root._iteratorParentNode = null;\n    }\n\n    let node = root;\n    let nextNode = null; // For finding an in-between node\n\n    while (node !== null) {\n      const cmp = comparator(value, node.value);\n\n      if (cmp === 0) {\n        break;\n      } else if (cmp < 0) {\n        if (node.left === null) {\n          break;\n        }\n\n        nextNode = node; // If we descend all right after this until there are\n        // no more right nodes, we want to return an\n        // \"in-between\" iterator ... pointing here.\n\n        node.left._iteratorParentNode = node;\n        node = node.left;\n      } else {\n        if (node.right !== null) {\n          node.right._iteratorParentNode = node;\n          node = node.right;\n        } else {\n          node = nextNode;\n          break;\n        }\n      }\n    }\n\n    return new BinaryTreeIterator(tree, node);\n  };\n\n  BinaryTreeIterator.left = tree => {\n    if (tree.root === null) {\n      return new BinaryTreeIterator(tree, null);\n    } else {\n      tree.root._iteratorParentNode = null;\n      const node = descendAllTheWay('left', tree.root);\n      return new BinaryTreeIterator(tree, node);\n    }\n  };\n\n  BinaryTreeIterator.right = tree => {\n    return new BinaryTreeIterator(tree, null);\n  };\n\n  const binaryTreeTraverse = (node, callback) => {\n    if (node !== null) {\n      binaryTreeTraverse(node.left, callback);\n      callback(node.value);\n      binaryTreeTraverse(node.right, callback);\n    }\n  }; // An AbstractBinaryTree has a @root. @root is null or an object with\n  // `.left`, `.right` and `.value` properties.\n\n\n  class AbstractBinaryTree {\n    toArray() {\n      const ret = [];\n      binaryTreeTraverse(this.root, function (value) {\n        return ret.push(value);\n      });\n      return ret;\n    }\n\n    clear() {\n      return this.root = null;\n    }\n\n    forEachImpl(callback, sortedSet, thisArg) {\n      let i = 0;\n      binaryTreeTraverse(this.root, function (value) {\n        callback.call(thisArg, value, i, sortedSet);\n        i += 1;\n      });\n    }\n\n    contains(value) {\n      const comparator = this.comparator;\n      let node = this.root;\n\n      while (node !== null) {\n        const cmp = comparator(value, node.value);\n\n        if (cmp === 0) {\n          break;\n        } else if (cmp < 0) {\n          node = node.left;\n        } else {\n          node = node.right;\n        }\n      }\n\n      return node !== null && comparator(node.value, value) === 0;\n    }\n\n    findIterator(value) {\n      return BinaryTreeIterator.find(this, value, this.comparator);\n    }\n\n    beginIterator() {\n      return BinaryTreeIterator.left(this);\n    }\n\n    endIterator() {\n      return BinaryTreeIterator.right(this);\n    }\n\n  }\n\n  class Node {\n    constructor(value) {\n      this.value = value;\n      this.left = null;\n      this.right = null;\n    }\n\n  }\n\n  const nodeAllTheWay = (node, leftOrRight) => {\n    while (node[leftOrRight] !== null) {\n      node = node[leftOrRight];\n    }\n\n    return node;\n  }; // Returns the subtree, minus value\n\n\n  const binaryTreeDelete = (node, value, comparator) => {\n    if (node === null) {\n      throw 'Value not in set';\n    }\n\n    const cmp = comparator(value, node.value);\n\n    if (cmp < 0) {\n      node.left = binaryTreeDelete(node.left, value, comparator);\n    } else if (cmp > 0) {\n      node.right = binaryTreeDelete(node.right, value, comparator); // This is the value we want to remove\n    } else {\n      if (node.left === null && node.right === null) {\n        node = null;\n      } else if (node.right === null) {\n        node = node.left;\n      } else if (node.left === null) {\n        node = node.right;\n      } else {\n        const nextNode = nodeAllTheWay(node.right, 'left');\n        node.value = nextNode.value;\n        node.right = binaryTreeDelete(node.right, nextNode.value, comparator);\n      }\n    }\n\n    return node;\n  };\n\n  class BinaryTreeStrategy extends AbstractBinaryTree {\n    constructor(options) {\n      super();\n      this.options = options;\n      this.comparator = this.options.comparator;\n      this.onInsertConflict = this.options.onInsertConflict;\n      this.root = null;\n    }\n\n    insert(value) {\n      const compare = this.comparator;\n\n      if (this.root !== null) {\n        let parent = this.root;\n        let leftOrRight = null;\n\n        while (true) {\n          const cmp = compare(value, parent.value);\n\n          if (cmp === 0) {\n            parent.value = this.onInsertConflict(parent.value, value);\n            return;\n          } else {\n            leftOrRight = cmp < 0 ? 'left' : 'right';\n\n            if (parent[leftOrRight] === null) {\n              break;\n            }\n\n            parent = parent[leftOrRight];\n          }\n        }\n\n        return parent[leftOrRight] = new Node(value);\n      } else {\n        return this.root = new Node(value);\n      }\n    }\n\n    remove(value) {\n      return this.root = binaryTreeDelete(this.root, value, this.comparator);\n    }\n\n  }\n\n  // It's copied from http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf.\n  // It's practically a copy-paste job, minus the semicolons. missing bits were\n  // filled in with hints from\n  // http://www.teachsolaisgames.com/articles/balanced_left_leaning.html\n  // Here are some differences:\n  // * This isn't a map structure: it's just a tree. There are no keys: the\n  //   comparator applies to the values.\n  // * We use the passed comparator.\n\n  class Node$1 {\n    constructor(value1) {\n      this.value = value1;\n      this.left = null;\n      this.right = null;\n      this.isRed = true; // null nodes -- leaves -- are black\n    }\n\n  }\n\n  const rotateLeft = h => {\n    const x = h.right;\n    h.right = x.left;\n    x.left = h;\n    x.isRed = h.isRed;\n    h.isRed = true;\n    return x;\n  };\n\n  const rotateRight = h => {\n    const x = h.left;\n    h.left = x.right;\n    x.right = h;\n    x.isRed = h.isRed;\n    h.isRed = true;\n    return x;\n  };\n\n  const colorFlip = h => {\n    h.isRed = !h.isRed;\n    h.left.isRed = !h.left.isRed;\n    h.right.isRed = !h.right.isRed;\n  };\n\n  const moveRedLeft = h => {\n    //throw 'Preconditions failed' if !(!h.left.isRed && !h.left.left?.isRed)\n    colorFlip(h);\n\n    if (h.right !== null && h.right.left !== null && h.right.left.isRed) {\n      h.right = rotateRight(h.right);\n      h = rotateLeft(h);\n      colorFlip(h);\n    }\n\n    return h;\n  };\n\n  const moveRedRight = h => {\n    //throw 'Preconditions failed' if !(!h.right.isRed && !h.right.left?.isRed)\n    colorFlip(h);\n\n    if (h.left !== null && h.left.left !== null && h.left.left.isRed) {\n      h = rotateRight(h);\n      colorFlip(h);\n    }\n\n    return h;\n  };\n\n  const insertInNode = (h, value, compare, onInsertConflict) => {\n    if (h === null) {\n      return new Node$1(value);\n    } //if h.left isnt null && h.left.isRed && h.right isnt null && h.right.isRed\n    //  colorFlip(h)\n\n\n    const cmp = compare(value, h.value);\n\n    if (cmp === 0) {\n      h.value = onInsertConflict(h.value, value);\n    } else if (cmp < 0) {\n      h.left = insertInNode(h.left, value, compare, onInsertConflict);\n    } else {\n      h.right = insertInNode(h.right, value, compare, onInsertConflict);\n    }\n\n    if (h.right !== null && h.right.isRed && !(h.left !== null && h.left.isRed)) {\n      h = rotateLeft(h);\n    }\n\n    if (h.left !== null && h.left.isRed && h.left.left !== null && h.left.left.isRed) {\n      h = rotateRight(h);\n    } // Put this here -- I couldn't get the whole thing to work otherwise :(\n\n\n    if (h.left !== null && h.left.isRed && h.right !== null && h.right.isRed) {\n      colorFlip(h);\n    }\n\n    return h;\n  };\n\n  const findMinNode = h => {\n    while (h.left !== null) {\n      h = h.left;\n    }\n\n    return h;\n  };\n\n  const fixUp = h => {\n    // Fix right-leaning red nodes\n    if (h.right !== null && h.right.isRed) {\n      h = rotateLeft(h);\n    } // Handle a 4-node that traverses down the left\n\n\n    if (h.left !== null && h.left.isRed && h.left.left !== null && h.left.left.isRed) {\n      h = rotateRight(h);\n    } // split 4-nodes\n\n\n    if (h.left !== null && h.left.isRed && h.right !== null && h.right.isRed) {\n      colorFlip(h);\n    }\n\n    return h;\n  };\n\n  const removeMinNode = h => {\n    if (h.left === null) {\n      return null;\n    }\n\n    if (!h.left.isRed && !(h.left.left !== null && h.left.left.isRed)) {\n      h = moveRedLeft(h);\n    }\n\n    h.left = removeMinNode(h.left);\n    return fixUp(h);\n  };\n\n  const removeFromNode = (h, value, compare) => {\n    if (h === null) {\n      throw 'Value not in set';\n    }\n\n    if (compare(value, h.value) < 0) {\n      if (h.left === null) {\n        throw 'Value not in set';\n      }\n\n      if (!h.left.isRed && !(h.left.left !== null && h.left.left.isRed)) {\n        h = moveRedLeft(h);\n      }\n\n      h.left = removeFromNode(h.left, value, compare);\n    } else {\n      if (h.left !== null && h.left.isRed) {\n        h = rotateRight(h);\n      }\n\n      if (h.right === null) {\n        if (compare(value, h.value) === 0) {\n          return null; // leaf node; LLRB assures no left value here\n        } else {\n          throw 'Value not in set';\n        }\n      }\n\n      if (!h.right.isRed && !(h.right.left !== null && h.right.left.isRed)) {\n        h = moveRedRight(h);\n      }\n\n      if (compare(value, h.value) === 0) {\n        h.value = findMinNode(h.right).value;\n        h.right = removeMinNode(h.right);\n      } else {\n        h.right = removeFromNode(h.right, value, compare);\n      }\n    }\n\n    if (h !== null) {\n      h = fixUp(h);\n    }\n\n    return h;\n  };\n\n  class RedBlackTreeStrategy extends AbstractBinaryTree {\n    constructor(options) {\n      super();\n      this.options = options;\n      this.comparator = this.options.comparator;\n      this.onInsertConflict = this.options.onInsertConflict;\n      this.root = null;\n    }\n\n    insert(value) {\n      this.root = insertInNode(this.root, value, this.comparator, this.onInsertConflict);\n      this.root.isRed = false; // always\n    }\n\n    remove(value) {\n      this.root = removeFromNode(this.root, value, this.comparator);\n\n      if (this.root !== null) {\n        this.root.isRed = false;\n      }\n    }\n\n  }\n\n  const InsertConflictResolvers = {\n    OnInsertConflictThrow: (oldValue, newValue) => {\n      throw new Error(\"Value already in set\");\n    },\n    OnInsertConflictReplace: (oldValue, newValue) => newValue,\n    OnInsertConflictIgnore: (oldValue, newValue) => oldValue\n  };\n\n  class SortedSet extends AbstractSortedSet {\n    constructor(options) {\n      options || (options = {});\n      options.strategy || (options.strategy = RedBlackTreeStrategy);\n      options.comparator || (options.comparator = function (a, b) {\n        return (a || 0) - (b || 0);\n      });\n      options.onInsertConflict || (options.onInsertConflict = InsertConflictResolvers.OnInsertConflictThrow);\n      super(options);\n    }\n\n  }\n  SortedSet.ArrayStrategy = ArrayStrategy;\n  SortedSet.BinaryTreeStrategy = BinaryTreeStrategy;\n  SortedSet.RedBlackTreeStrategy = RedBlackTreeStrategy;\n  Object.assign(SortedSet, InsertConflictResolvers);\n\n  return SortedSet;\n\n})));\n//# sourceMappingURL=sorted-set.js.map\n"],"names":["global","factory","module","this","AbstractSortedSet","options","value","callback","thisArg","ret","index","self","Iterator","priv","index1","binarySearchForIndex","array","comparator","low","high","mid","ArrayStrategy","sortedSet","data","len","i","descendAllTheWay","leftOrRight","node","parent","moveCursor","rightOrLeft","BinaryTreeIterator","tree1","node1","tree","root","nextNode","cmp","binaryTreeTraverse","AbstractBinaryTree","Node","nodeAllTheWay","binaryTreeDelete","BinaryTreeStrategy","compare","Node$1","value1","rotateLeft","h","x","rotateRight","colorFlip","moveRedLeft","moveRedRight","insertInNode","onInsertConflict","findMinNode","fixUp","removeMinNode","removeFromNode","RedBlackTreeStrategy","InsertConflictResolvers","oldValue","newValue","SortedSet","a","b"],"mappings":"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","x_google_ignoreList":[0]}